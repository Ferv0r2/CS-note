# CS 전공 지식

도서명 : 면접을 위한 CS 전공지식노트
예제소스 : https://github.com/gilbutITbook/080326

# 1 - 디자인 패턴과 프로그래밍 패러다임

## 1.1 디자인 패턴

- 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것을 의미

### 1.1.1 싱글톤 패턴 (Singletone pattern)

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

**장점**

- 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어듦

**단점**

- 의존성이 높아짐
- 독립적인 인스턴스를 만들기가 어려워 TDD(Test Driven Development)를 할 때 걸림돌이 됨

#### 의존성 주입 (DI, Dependency Injection)

싱글톤 패턴은 사용하기가 쉽고 굉장히 실용적이지만 모듈 간의 결합을 강하게 만들 수 있다는 단점이 있기에 모듈 간의 결합을 조금 더 느슨하게 만들어 해결이 가능함, 이를 통해 메인 모듈은 하위 모듈에 대한 의존성이 떨어지며 이를 '디커플링 된다'고도 함

**장점**

- 모듈을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션 하기도 수월함
- 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 앱 의존성 방향이 일관되고 앱을 쉽게 추론할 수 있으며 모듈 간의 관계들이 조금 더 명확해짐

**단점**

- 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 패널티가 생기기도 함

**원칙**

- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
- 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 함

### 1.1.2 팩토리 패턴 (Factory pattern)

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

**장점**

- 클라이언트 코드로부터 서브 클래스의 인스턴스화를 제거하여 서로 간의 종속성을 낮춤
- 결합도를 느슨하게 하며 확장을 쉽게 함

**단점**

- 새로 생성할 객체가 늘어날 때마다, Factory 클래스에 추가해야하므로 클래스가 많아짐

### 1.1.3 전략 패턴 (Strategy pattern)

객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

**장점**

- 공통 로직이 부모 클래스에 있지 않고 Context라는 별도의 클래스에 존재하기 때문에 구현체들에 대한 영향도가 적음
- Strategy라는 인터페이스에 의존하고 있기 때문에 구현체를 갈아끼우기 쉬움

**단점**

- 로직이 늘러날 때마다 구현체 클래스가 늘어남
- Context와 Strategy를 한번 조립하면 전략을 변경하기 힘듦

#### Passport

전략 패턴을 활용한 라이브러리
Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로 OAuth 전략 등을 지원

### 1.1.4 옵저버 패턴 (Observer pattern)

어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller) 패턴에도 사용

**장점**

- 실시간으로 한 객체의 변경사항을 다른 객체에 전파할 수 있음
- 느슨한 결합으로 시스템이 유연하고 객체 간의 의존성을 제거함

**단점**

- 사용량이 과하면 상태 관리가 힘듦
- 데이터 배분에 문제가 생기면 위험성이 커질 수 있음

#### 프록시 객체 (Proxy Object)

프록시 객체는 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 개체를 뜻하며, JS에서 프록시 객체는 두 개의 매개변수를 가짐

- target : 프록시할 대상
- handler : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수

### 1.1.5 프록시 패턴과 프록시 서버

#### 프록시 패턴 (Proxy pattern)

대상 객체에 접근하기 전에 그 접근에 대한 흐름이 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴

**장점**

- 메모리 사용량이 큰 객체가 로딩 전에 프록시를 통해서 참조 가능
- 로컬에 있지 않고 떨어져 있는 객체 사용 가능
- 원래 객체의 접근에 대해서 사전처리 작업 가능

**단점**

- 객체 생성에 한 단계를 거치므로 빈번한 객체 생성이 필요한 경우 성능 저하 발생 가능
- 코드 가독성 저하

#### 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킴

**프록시 서버로 쓰는 nginx**

nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹서버이며, 주로 nodejs 서버 앞단의 프록시 서버로 활용됨

**프록시 서버로 쓰는 CloudFlare**

CloudFlare는 전 세계적으로 분산도니 서버가 있고 이를 통해 어떻나 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스로 CDN 뿐만 아니라 DDOS 공격 방어, HTTPS 구축 등의 이점이 있음

- DDOS 공격 방어 : 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단함

- HTTPS 구축 : 서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있지만, CloudFlare를 사용하면 별도의 인증서 설치 없이 좀 더 손쉽게 구축이 가능

**CORS와 프록시 서버**

프론트엔드 서버 앞단에 프록시 서버를 놓아 로컬 내에서 API 요청시 발생하는 CORS 에러를 해결할 수 있음

### 1.1.6 이터레이터 패턴 (Iterator pattern)

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

**장점**

- 다양한 데이터 순회 알고리즘을 코드로 분리할 수 있음 (단일책임원칙)
- 기존 코드를 수정하지 않고도 새로운 타입의 컬렉션과 이터레이터를 추가할 수 있음 (개방/폐쇄 원칙)
- 객체마다 이터레이터를 가지고 있기 때문에 같은 컬렉션을 병렬처리할 수 있음

**단점**

- 간단한 컬렉션인 경우 이터레이터 패턴을 적용하는 것은 과함
- 컬렉션 특정 위치의 요소에 바로 접근해야 할 때, 이터레이터를 사용하는 것은 비효율적일 수 있음

### 1.1.7 노출모듈 패턴 (Revealing module pattern)

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

**장점**

- 클로저를 통해 함수와 변수를 지역화
- 클로저를 통해 함수와 변수를 지역화
- 명시적으로 public 메소드와 변수를 제공해 명시성을 높임

**단점**

- private 메소드에 접근할 방법이 없음
- private 메소드에 대해 함수 확장에 어려움
- private 메소드를 참조하는 public 메소드를 수정하기 어려움

### 1.1.8 MVC 패턴 (Model - View - Controller pattern)

모델, 뷰, 컨트롤러로 이루어진 디자인 패턴

**장점**

- 비교적 간단한 패턴으로 구조파악과 확장이 쉬움
- 재사용성과 확장성이 용이함

**단점**

- 뷰와 모델의 완벽한 분리가 어렵고 앱이 커지면 컨트롤러의 코드량이 커져 유지보수가 어려움
- 앱이 복잡해질수록 모델과 뷰의 관계가 복잡해짐

#### MVC 패턴의 예) 리액트

가상 DOM을 통해 실제 DOM을 조작하는 것을 추상화하여 성능을 높임.  
대표적인 특성으로는 불변성이 있음.

### 1.1.9 MVP 패턴 (Model - View - Presenter pattern)

MVC 패턴으로부터 파생되었으며 C에 해당하는 컨트롤러가 프레젠터로 교체된 패턴

**장점**

- 뷰와 모델 사이의 의존성이 없음

**단점**

- MVC 패턴의 단점인 뷰와 모델 사이의 의존성은 해결되었지만, 뷰와 프레젠터 사이의 의존성이 높아짐
- 어플리케이션이 복잡해질수록 뷰와 프레젠터 사이의 의존성이 강해짐

### 1.1.10 MVVM 패턴 (Model - View - View - Model pattern)

MVC 패턴으로부터 파생되었으며 C에 해당하는 컨트롤러가 뷰모델로 바뀐 패턴  
뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과 다른게 커맨드와 데이터 바인딩을 가지는 것이 특징임

**장점**

- 뷰와 모델 사이의 의존성이 없음

**단점**

- 설계가 어려움
- 간단한 처리를 해주어야 할 때, 데이터 바인딩의 추가적인 코딩이 필요해 코드량이 늘어남

#### MVVM 패턴의 예) 뷰

watch와 computed 등으로 쉽게 반응형적인 값들을 구축할 수 있음  
함수를 사용하지 않고 값 대입만으로도 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있음

## 1.2 프로그래밍 패러다임

- 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
- 크게 선언형, 명령형으로 나뉘며 선언형은 함수형이라는 하위 집합을 가지고 명령형은 다시 객체지향 절차지향으로 나뉨

```
      프로그래밍 패러다임
         /         \
     선언형       명령형
       /          /  \
    함수형 객체지향형 절차지향형
```

### 1.2.1 선언형과 함수형 프로그래밍

#### 선언형 프로그래밍 ( Declarative Programming )

- '무엇을' 풀어내는가에 집중하는 패러다임
- '프로그램은 함수로 이루어진 것이다'라는 명제가 담겨 있는 패러다임

#### 함수형 프로그래밍 ( Functional Programming )

- 선언형 패러다임의 일종
- 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차ㅎ 함수를 통해 재사용성을 높인 프로그래밍 패러다임
- 자바스크립트는 단순하고 유연한 언어이며, 함수가 일급 객체이기 때문에 객체지향 프로그래밍보다는 함수형 프로그래밍 방식이 선호됨

### 1.2.2 객체지향 프로그래밍 ( Object-Oriented Programming )

- 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
- 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림

**특징**

- 추상화 (abstraction) : 복잡한 시스템으로부터 핵심적ㅇ니 개념 또는 기능을 간추려내는 것. ex) 군인, 장교, 키180, 안경씀 등
- 캡슐화 (encapsulation) : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
- 상속성 (inheritance) : 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확정하는 것을 말함. 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요함
- 다형성 (polymorphism) : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말함. 대표적으로 오버로딩, 오버라이딩이 있음

**설계원칙**

- 객체지향 프로그래밍을 설계할 때는 SOLID 원칙을 지켜야 함
- S: 단일 책임 원칙
- O: 개방-폐쇄 원칙
- L: 리스코프 치환 원칙
- I: 인터페이스 분리 원칙
- D: 의존 역전 원칙

### 1.2.3 절차형 프로그래밍 ( Procedural Programming )

- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어짐

**장점**

- 일의 진행 방식대로 코드를 구현하면 되기에 코드의 가독성이 좋으며 실행 속도가 빠름

**단점**

- 모듈화하기 어렵고 유지 보수성이 떨어짐

### 1.2.4 패러다임의 혼합

    가장 좋은 패러다임은 없음

비즈니스 로직이나 서비스의 특징을 고려해서 패러다임을 정하는 것이 좋음  
하나의 패러다임을 기반으로 통일하여 서비스를 구축하는 것도 좋은 생각이지만 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만을 취해 개발하는 것이 좋음

    ex) 백엔드에 머신 러닝 파이프라인과 거래 관련 로직이 있다면
    - 머신 러닝 파이프라인은 절차지향형 패러다임
    - 거래관련 로직은 함수형 프로그램

    을 적용하는 것이 좋음
